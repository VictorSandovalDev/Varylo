import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { ChannelType, MessageDirection, Role } from '@prisma/client';
import { runAutomationPipeline } from '@/jobs/pipeline';

export const dynamic = 'force-dynamic';

const CORS_HEADERS: Record<string, string> = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, x-webchat-key',
    'Cache-Control': 'no-store, no-cache, must-revalidate',
};

export async function OPTIONS() {
    return new NextResponse(null, { status: 204, headers: CORS_HEADERS });
}

/** Find the WEB_CHAT channel by API key */
async function findChannelByKey(apiKey: string) {
    const channels = await prisma.channel.findMany({
        where: { type: ChannelType.WEB_CHAT, status: 'CONNECTED' },
    });
    return channels.find((c) => {
        const config = c.configJson as { apiKey?: string } | null;
        return config?.apiKey === apiKey;
    });
}

/**
 * POST /api/webchat  — send a message (creates session automatically on first message)
 * GET  /api/webchat?sessionId=xxx&after=timestamp  — poll for messages
 */
export async function POST(req: NextRequest) {
    try {
        const apiKey = req.headers.get('x-webchat-key');
        if (!apiKey) {
            return NextResponse.json({ error: 'Missing x-webchat-key header' }, { status: 401, headers: CORS_HEADERS });
        }

        const channel = await findChannelByKey(apiKey);
        if (!channel) {
            return NextResponse.json({ error: 'Invalid API key' }, { status: 401, headers: CORS_HEADERS });
        }

        const body = await req.json();
        const { content, sessionId, visitorName, visitorEmail, origin: visitorOrigin } = body;

        if (!content?.trim()) {
            return NextResponse.json({ error: 'Missing content' }, { status: 400, headers: CORS_HEADERS });
        }

        // If no sessionId, create session on the fly with the first message
        let currentSessionId = sessionId;
        let conversation;

        if (!currentSessionId) {
            // Use Origin header or body origin as website identifier
            const originUrl = visitorOrigin || req.headers.get('origin') || req.headers.get('referer') || 'Web';
            const result = await createSession(channel, { visitorName, visitorEmail, origin: originUrl });
            currentSessionId = result.conversationId;
            conversation = result.conversation;
        } else {
            conversation = await prisma.conversation.findFirst({
                where: {
                    id: currentSessionId,
                    companyId: channel.companyId,
                    channelId: channel.id,
                },
                include: { contact: true },
            });
        }

        if (!conversation) {
            return NextResponse.json({ error: 'Session not found' }, { status: 404, headers: CORS_HEADERS });
        }

        // Save inbound message
        const message = await prisma.message.create({
            data: {
                companyId: channel.companyId,
                conversationId: currentSessionId,
                direction: MessageDirection.INBOUND,
                from: conversation.contact.name || 'Visitante Web',
                to: 'webchat',
                content: content.trim(),
            },
        });

        // Update conversation timestamps
        await prisma.conversation.update({
            where: { id: currentSessionId },
            data: { lastMessageAt: new Date(), lastInboundAt: new Date() },
        });

        // Run automation pipeline and wait for response
        await runAutomationPipeline(currentSessionId, content.trim(), channel.automationPriority);

        // Fetch any new messages generated by the pipeline (AI/chatbot responses)
        const responses = await prisma.message.findMany({
            where: {
                conversationId: currentSessionId,
                createdAt: { gt: message.createdAt },
            },
            orderBy: { createdAt: 'asc' },
            select: {
                id: true,
                direction: true,
                content: true,
                from: true,
                createdAt: true,
            },
        });

        return NextResponse.json(
            { sessionId: currentSessionId, messageId: message.id, responses },
            { headers: CORS_HEADERS }
        );
    } catch (error) {
        console.error('[WebChat] Error:', error);
        return NextResponse.json({ error: 'Internal error' }, { status: 500, headers: CORS_HEADERS });
    }
}

export async function GET(req: NextRequest) {
    try {
        const apiKey = req.headers.get('x-webchat-key');
        if (!apiKey) {
            return NextResponse.json({ error: 'Missing x-webchat-key header' }, { status: 401, headers: CORS_HEADERS });
        }

        const channel = await findChannelByKey(apiKey);
        if (!channel) {
            return NextResponse.json({ error: 'Invalid API key' }, { status: 401, headers: CORS_HEADERS });
        }

        const sessionId = req.nextUrl.searchParams.get('sessionId');
        const after = req.nextUrl.searchParams.get('after');

        if (!sessionId) {
            return NextResponse.json({ error: 'Missing sessionId' }, { status: 400, headers: CORS_HEADERS });
        }

        // Verify conversation belongs to this channel's company
        const conversation = await prisma.conversation.findFirst({
            where: {
                id: sessionId,
                companyId: channel.companyId,
                channelId: channel.id,
            },
        });

        if (!conversation) {
            return NextResponse.json({ error: 'Session not found' }, { status: 404, headers: CORS_HEADERS });
        }

        const messages = await prisma.message.findMany({
            where: {
                conversationId: sessionId,
                ...(after ? { createdAt: { gt: new Date(after) } } : {}),
            },
            orderBy: { createdAt: 'asc' },
            select: {
                id: true,
                direction: true,
                content: true,
                from: true,
                createdAt: true,
            },
        });

        return NextResponse.json({ messages }, { headers: CORS_HEADERS });
    } catch (error) {
        console.error('[WebChat] Error fetching messages:', error);
        return NextResponse.json({ error: 'Internal error' }, { status: 500, headers: CORS_HEADERS });
    }
}

/** Creates contact + conversation, returns the conversation with contact included */
async function createSession(
    channel: { id: string; companyId: string; automationPriority: any },
    opts: { visitorName?: string; visitorEmail?: string; origin?: string }
) {
    const companyId = channel.companyId;

    // Extract clean domain from origin URL
    let originDomain = 'Web';
    try {
        if (opts.origin && opts.origin !== 'Web') {
            originDomain = new URL(opts.origin).hostname.replace(/^www\./, '');
        }
    } catch {
        originDomain = opts.origin || 'Web';
    }

    const visitorId = originDomain;
    const name = opts.visitorName || `Visitante ${originDomain}`;

    const contact = await prisma.contact.create({
        data: {
            companyId,
            phone: visitorId,
            name,
            email: opts.visitorEmail || undefined,
        },
    });

    // Check for active AI agent on this channel
    const activeAiAgent = await prisma.aiAgent.findFirst({
        where: {
            companyId,
            active: true,
            channels: { some: { id: channel.id } },
        },
    });

    let conversation;

    if (activeAiAgent) {
        conversation = await prisma.conversation.create({
            data: {
                companyId,
                channelId: channel.id,
                contactId: contact.id,
                status: 'OPEN',
                handledByAiAgentId: activeAiAgent.id,
            },
            include: { contact: true },
        });
    } else {
        const agents = await prisma.user.findMany({
            where: { companyId, active: true, role: Role.AGENT },
            select: { id: true },
        });

        const selectedAgentId = agents.length > 0
            ? agents[Math.floor(Math.random() * agents.length)].id
            : null;

        conversation = await prisma.conversation.create({
            data: {
                companyId,
                channelId: channel.id,
                contactId: contact.id,
                status: 'OPEN',
                assignedAgents: selectedAgentId ? { connect: { id: selectedAgentId } } : undefined,
            },
            include: { contact: true },
        });
    }

    return { conversationId: conversation.id, conversation };
}
